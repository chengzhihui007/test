前面2节提到，Redis高可用的方案包括持久化、主从复制(及读写分离)、哨兵和集群。其中持久化侧重解决的是Redis数据的单机备份问题(从内存到硬盘的备份);而主从复制则侧重解决数据的多级热备。此外，主从复制还可以实现负载均衡和故障恢复。
	本节内容：如何使用主从复制、主从复制的原理(重点是全量复制和部分复制、以及心跳机制)、实际应用中需要注意的问题(如数据不一致问题、复制超时问题、复制缓冲区溢出问题)、主从复制相关的配置(重点是repl-timeout、client-output-buffer-limit slave)等。
一。主从复制概述
	1.主从复制
		主从复制是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave);数据的复制是单向的，只能从主节点到从节点。
		默认情况下，每台Redis服务器都是主从节点，且一个主节点可以有多个从节点(或没有从节点),但一个从节点只能有一个主节点。
	2.主从复制的作用
		主从复制的作用主要包括：
			·数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
			·故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复，但实际上是一种服务的冗余。
			·负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务(即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点),分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。
			·高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。
二。如何使用主从复制
	为了更直观的理解主从复制，在介绍其内部原理之前，先说明如何操作才能开启主从复制。
	1.建立复制
		主从复制的开启，完全是在从节点发起的，不需要主节点做任何事情。
		从节点开启主从复制，有3中方式：
			·配置文件
				在从服务器的配置文件中加入:slaveof<masterip><masterport>
			·启动命令
				redis-server启动命令后加入:slaveof<masterip><masterport>

			·客户端命令
				Redis服务器启动后直接通过客户端执行命令：slaveof<masterip><masterport>,则该Redis实例称为从节点。
		上述3种方式是等效的，下面以客户端命令的方式为例，看一下当执行了slaveof后，Redis和从节点的变化。
	2.实例
		准备工作：启动两个节点。
			建立复制
				redis-cli -p 6380
					get mykey
					set mykey myvalue
				建立slave库
				redis-cli -p 6379
					slaveof 127.0.0.1 6379
					get mykey	
			此时，即同步了。
	3.断开复制
		 使用命令slaveof no one断开。需要注意的是，从节点断开复制后，不会删除已有数据，只是不再接受主节点新的数据变化。
三。主从复制的实现原理
	主从复制过程大体可以分为3个阶段：连接建立阶段(即准备阶段)、数据同步阶段、命令传播阶段。
	1.连接建立阶段
		该阶段的主要作用是在主从节点之间建立连接，为数据同步做好准备。
		步骤1：保存主节点信息
			从节点服务器内部维护了两个字段，即masterhost和masterport字段，用于存储主节点的ip和port信息。
			需要注意的是，slaveof是异步命令，从节点完成主节点ip和port的保存后，向发送slaveof命令的客户端直接返回OK,实际的复制操作在这之后才开始进行。
		步骤2：建立socket连接
			从节点每秒1次调用复制定时函数replicationCron(),如果发现了有主节点可以连接，便会根据主节点的ip和port，创建socket连接。如果成功，则：
			从节点为该socket建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接受RDB文件、接受命令传播等。
			主节点接收到从节点的socket连接后(即accept之后),为该socket创建相应的客户端状态，并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行。
		步骤3：发送ping命令
			从节点成为主节点的客户端之后，发送ping命令进行首次请求，目的是检查socket连接是否可用以及主节点当前是否能够处理请求。
			从节点发送ping命令后，可能出现3种情况：
				·返回pong:正常。
				·超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。
				·返回pong以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。
		步骤4：身份验证
			如果从节点中设置了masterauth选项，则从节点需要向主节点进行身份验证;没有设置该选项则不需要验证。从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值。
			如果主节点设置密码的状态，与从节点masterauth的状态一致(一致是指都存在，且密码相同，或者都不存在),则身份验证通过，复制过程继续；如果不一致，则从节点断开socket连接，并重连。
		步骤5：发送从节点端口信息
			身份验证后，从节点会向主机诶单发送其监听的端口号(前述例子中为6380)，主节点将该信息保存到该从节点对应的客户端的slave_listening_port字段中；该端口信息除了在主节点中执行info Replication时显示以外，没有其他作用。
	2.数据同步阶段
		主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。具体执行的方式是：从节点向主节点发送psync命令(Redis2.8以前是sync命令)，开始同步。
		数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为全量复制和部分复制，下面详述。
		注意：在数据同步阶段之前，从节点是主节点的客户端，主节点不是从节点的客户端；而到了这一阶段以及以后，主从节点互为客户端。原因在于：在此之前，主节点只需要相应从节点的请求即可，不需要主动发请求，而在数据同步阶段和后面的命令传播阶段，主节点需要主动向从节点发送请求(如推送缓冲区中的写命令),才能完成复制。
	3.命令传播阶段
		数据同步阶段完成后，主从节点进入命令传播阶段。在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证从节点数据的一致性。
		在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK.由于心跳机制的原理涉及部分复制，因此将在介绍了部分复制的相关内容后单独介绍该心跳机制。
		

		延迟不一致
			需要注意的是，命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复。因此实际上主从节点之间很难保持实时的一致性，延迟再说难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的repl-disable-tcp-nodelay配置等有关。
			repl-disable-tcp-nodelay no: 该配置作用于命令传播阶段，控制主节点是否禁止与从节点的TCP_NODELAY。默认no，即不禁止tcp_nodelay。当设置为yes时，tcp会对包进行合并从而减少带宽，但是发送的频率会降低，从节点数据延迟增加，一致性变差；具体发送频率与Linux内核的配置有关，默认配置为40ms。当设置为no时，TCP会立马将主节点的数据发送给从节点，带宽增加但延迟变小。
		一般来说，只有当应用对Redis数据不一致的容忍度较高，且主从节点之间网络状况不好时，才会设置为yes；多数情况使用默认值no.
四。全量复制和部分复制
	在Redis2.8以前，从节点向主节点发送sync命令请求同步数据，此时的同步方式是全量复制；在Redis2.8及以后，从节点可以发送psync命令请求同步数据，此时根据主从节点当前状态的不同，同步方式可能是全量复制或部分复制。后文介绍以Redis2.8及以后版本为例。
		·全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。
		·部分复制：用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，造成主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。
	1.全量复制
		Redis通过psync命令进行全量复制的过程如下：
			·从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行全量复制。具体判断过程需要在讲述了部分复制原理后再介绍。
			·主节点收到全量复制的命令后，执行bgsave,在后台生成RDB文件，并使用一个缓冲区(称为复制缓冲区)记录从现在开始执行的所有写命令。
			·主节点的bgsave执行完成后，将RDB文件发送给从节点；从节点首先清除自己的旧数据，然后载入接收的RDB文件，将数据库状态更新至主节点执行bgsave时的数据库状态。
			·主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态。
			·如果从节点开启了AOF，则会触发bgrewriteaof的执行，从而保证AOF文件更新至主节点的最新状态。
		下面是日志：
			主节点日志：
				https://mmbiz.qpic.cn/mmbiz_png/tibrg3AoIJTv3kQ9UYuAWsv3PHz6U0IKKTI8QibBzV4sgpDt4mnSZgcBu2ln4T9DCoosYJImc8KRm6TENB69rWSw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1
			从节点日志：
				https://mmbiz.qpic.cn/mmbiz_jpg/tibrg3AoIJTv3kQ9UYuAWsv3PHz6U0IKKo83kiacH0AxflvZiceBMHnTCR3qyyy3KfZxtNItbAbOOk8EibyrrSWN4A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1
		其中，有几点需要注意：
			·从节点接收了来自主节点的89260个字节的数据。
			·从节点在载入主节点的数据之前要先将老数据清除；
			·从节点在同步完数据后，调用了bgrewriteaof.
		通过全量复制的过程可以看出，全量复制是非常重型的操作：
			·主节点通过bgsave命令fork子进程进行RDB持久化，该过程是非常消耗CPU,内存(页表复制),硬盘IO的。
			·主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大消耗。
			·从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令。如果从节点执行bgwriteaof，也会带来额外的消耗。
	2.部分复制
		由于全量复制在主节点数据量较大时效率太低，因此Redis2.8K爱是提供部分复制，用于处理网络中断时的数据同步。
		部分复制的实现，依赖于三个重要的概念：
			
			复制偏移量
				主节点和从节点分别维护一个复制偏移量(offset),代表的是主节点向从节点传递的字节数；主节点每次向从节点传播N个字节数据时，主节点的offset增加N；从节点每次收到主节点传来的N个字节数据时，从节点的offset增加N。
				offset用于判断主从节点的数据库状态是否一致：如果二者offset相同，则一致，不同则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。例如，如果主节点的offset是1000，而从节点的offset是500，那么部分复制就需要将offset为501-1000的数据传递给从节点，而offset为501-1000的数据存储的位置，就是下面要介绍的复制积压缓冲区。
			复制积压缓冲区
				复制积压缓冲区是由主节点维护的、固定长度的、先进先出(FIFO)队列，默认大小1MB;当主节点开始有从节点时创造，其作用是备份主节点最近发送给从节点的数据。注意，无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区。
				在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份；除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量(offset).由于复制积压缓冲区定长且先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。
				由于该缓冲区长度固定且有限，因此可以备份的写命令也有限，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。反过来说，为了提高网路中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置repl-backlog-size)来设置；例如如果网络中断的平均时间是60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB,则复制积压缓冲区的平均需求为6MB,保险起见，可以设置为12MB,来保证绝大多数断线情况都可以使用部分复制。
		
				从节点将offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制：
					·如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；
					·如果offset偏移量之后的数据已不在复制积压缓冲区中(数据已被挤出),则执行全量复制。



			服务器运行ID(runid)
				每个Redis节点(无论主从),在启动时都会自动生成一个随机ID(每次启动都不一样),由40个随机的十六进制字符组成；runid用来唯一识别一个Redis节点。通过info server命令，可以查看节点的runid;
				主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来；当断线重连时，从节点会将这个runid发送给主节点；主节点会根据runid判断能否进行部分复制：
					·如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主机诶单会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况);
					·如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。
	3.psync命令的执行
		在了解了复制偏移量、复制积压缓冲区、节点运行id之后，本节将介绍psync命令的参数和返回值，从而说明psync命令执行过程中，主从节点是如何确定使用全量复制还是部分复制的。
		psync命令的执行过程可以参见下图：
				https://mmbiz.qpic.cn/mmbiz_jpg/tibrg3AoIJTv3kQ9UYuAWsv3PHz6U0IKKgmicpexyWibxn2G5NFdoWTm7ac3ooLZV44vMKIdqlVDlib8iauvsKy3pmg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1			(1)首先，从节点根据当前状态，决定如何调用psync命令：
			·如果从节点之前未执行过slaveof或最近执行了slaveof no one, 则从节点发送命令为psync ? -1,向主节点请求全量复制；
			·如果从节点之前执行了slaveof,则发送命令为psync<runid><offset>,其中runid为上次复制的主节点的runid,offset为上次复制截止时从节点保存的复制偏移量。
		  (2)主节点根据收到的psync命令及当前服务器状态来决定执行全量复制还是部分复制：
			·如果主节点版本低于Redis2.8.则返回-ERR回复，此时从节点重新发送sync命令执行全量复制；
			·如果主机诶单版本够新、runid与从节点发送的runid相同，且从节点发送的offset之后的数据在复制积压缓冲区中都存在，则回复+CONTINUE，表示将进行部分复制，从节点等待主节点发送其缺少的数据即可；
			·如果主节点版本够新，但runid与从节点发送的runid不同，或从节点发送的offset之后的数据已不在复制积压缓冲区中(在队列中被挤出了)，则回复+FULLRESYNC<runid><offset>,表示要进行全量复制。其中runid表示主节点当前的runid，offset表示主节点当前的offset，从节点保存这两个值，以备使用。
	4.部分复制演示
		网络中断
			网络中断一段时间后，主节点和从节点都会发现失去了与对方的连接(关于主从节点对超时的判断机制，后面会有说明);此后，从节点便开始执行对主节点的重连，由于此时网络还没有恢复，重连失败，从节点会一直尝试重连。
			主节点日志：
				https://mmbiz.qpic.cn/mmbiz_png/tibrg3AoIJTv3kQ9UYuAWsv3PHz6U0IKK523yqzVukzLSkQFyTZZFPBpo1OHpy4mG9Re2u5XfRZ2hDhLqyU3Oag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1
			从节点日志：
				https://mmbiz.qpic.cn/mmbiz_jpg/tibrg3AoIJTv3kQ9UYuAWsv3PHz6U0IKK4QcU0pHJat5cISgtOmYzFELk4lhmWTU6LFybC3GC10MS8icjGuMaJ0Q/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1
		网络恢复
			网络恢复后，从节点连接主节点成功，并请求进行部分复制，主节点接收请求后，二者进行部分复制以同步数据。
			主节点日志：
				https://mmbiz.qpic.cn/mmbiz_png/tibrg3AoIJTv3kQ9UYuAWsv3PHz6U0IKKfK6rzwVF6wKR8z7ibxI6Wm7Fw2dicZscfeCtYXgQBKEqMoScHFA1CRicA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1
			从节点日志：
				https://mmbiz.qpic.cn/mmbiz_jpg/tibrg3AoIJTv3kQ9UYuAWsv3PHz6U0IKKjEXiaNQgaFG0zQGnqERQ49RPEmkkOClEfyYDDwM6U3gc7RicYGV9ic30Q/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1



五。命令传播阶段心跳机制
	在命令传播阶段，除了发送写命令，主节点还维持着心跳机制：PING和REPLCONF ACK.心跳机制对于主从复制的超时判断、数据安全等有作用。
	1.主-->从：PING
		每隔指定的时间，主节点会向节点发送PING命令，这个PING命令的作用，主要是为了让从节点进行超时判断。
		PING发送的频率由repl-ping-slave-period参数控制，单位是秒，默认值是10s。
		关于该PING命令究竟是由主节点发送还是相反，有争议。因此在Redis的官方文档中，对该参数的注释说明是从节点向主节点发送PING命令，如下图所示：
			https://mmbiz.qpic.cn/mmbiz_png/tibrg3AoIJTv3kQ9UYuAWsv3PHz6U0IKKRB70hEjn48kzbibABDumdRMvAFaT6ysz1fzGovdTJAaZPpSDsoAR6VA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1
		但是根据该参数的名称(含有ping-slave)及代码实现，我认为该PING命令是主节点发给从节点的。相关代码如下：
		https://mmbiz.qpic.cn/mmbiz_jpg/tibrg3AoIJTv3kQ9UYuAWsv3PHz6U0IKKqURfCMLrYvSHbUFAeoY7yIz71CSRTMtLYmTBqfeYoCFfPIdNkfV3aw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1

	2.从-->主：REPLCONF ACK
		在命令传播阶段，从节点会向主节点发送REPLCONF ACK命令，频率是每秒1次；命令格式为：REPLCONF ACK{offset},其中offset指从节点保存的复制偏移量。
		REPLCONF ACK命令的作用包括：
		
			实时监测主从节点网络状态
				该命令会被主节点用于复制超时的判断。此外，在主节点中使用info Replication,可以看到其从节点的状态中的lag值，代表的是主节点上次收到该REPLCONF ACK命令的时间间隔，在正常情况下，该值应该是0或1，如下图所示：
			https://mmbiz.qpic.cn/mmbiz_png/tibrg3AoIJTv3kQ9UYuAWsv3PHz6U0IKKWEzrhuvKNUvBPTpyWuskgktyiaZLZsCMK71o4YUqXBrmLiaHibuqer7LA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1

			检测命令丢失
				从节点发送了自身的offset，主机诶单会与自己的offset对比，如果从节点数据缺失(如网络丢包),主节点会推送缺失的数据(这里也会利用复制积压缓冲区).注意，offset和复制积压缓冲区，不仅可以用于部分复制，也可以用于处理命令丢失等情形；区别在于前者是在断线重连后进行的，而后者是在主从节点没有断线的情况下进行的。
			辅助保证从节点的数量和延迟
				Redis主节点中使用min-slave-to-write和min-slaves-max-lag参数，来保证主节点在不安全的情况下不会执行写命令。
				所谓不安全，是指从节点数量太少，或延迟过高。例如min-slaves-to-write和min-slaves-max-lag分别是3和10，含义是如果从节点数量小于3个，或者所有从节点的延迟值都大于10s，则主节点拒绝执行写命令。而这里从节点延迟值的获取，就是通过主节点接收到REPLCONF ACK命令的时间来判断的，即前面所说的info Replication中的lag值。
